C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2021 15:33:06 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include<reg51.h>
   2          #include<stdio.h>
   3          #define display_port P3      //Data pins connected to port 2 on microcontroller
   4          #define toDAC P2          
   5          sbit rs = P3^0;  //RS pin connected to pin 2 of port 3
   6          sbit rw = P3^1;  // RW pin connected to pin 3 of port 3
   7          sbit e =  P3^2;  //E pin connected to pin 4 of port 3
   8          sbit C4 = P1^0;  // Connecting keypad to Port 1
   9          sbit C3 = P1^1;
  10          sbit C2 = P1^2;
  11          sbit C1 = P1^3;
  12          sbit R4 = P1^4;
  13          sbit R3 = P1^5;
  14          sbit R2 = P1^6;
  15          sbit R1 = P1^7;
  16          
  17          unsigned int key;
  18          
  19          void msdelay(unsigned int time)  // Function for creating delay in milliseconds.
  20          {
  21   1          unsigned i,j ;
  22   1          for(i=0;i<time;i++)
  23   1        {  
  24   2            for(j=0;j<1275;j++);
  25   2        }
  26   1      }
  27          
  28          void lcd_cmd(unsigned char command)  //Function to send command instruction to LCD
  29          {
  30   1          display_port = (command & 0xF0);
  31   1          rs= 0;
  32   1          rw=0;
  33   1          e=1;
  34   1          msdelay(20);
  35   1          e=0;
  36   1        msdelay(20);
  37   1        display_port = ((command<<4) & 0xF0);
  38   1          rs= 0;
  39   1          rw=0;
  40   1          e=1;
  41   1          msdelay(20);
  42   1          e=0;
  43   1      }
  44          void lcd_char_data(unsigned char disp_data)  //Function to send display data to LCD
  45          {
  46   1          display_port = (disp_data & 0xF0);
  47   1          rs= 1;
  48   1          rw=0;
  49   1          e=1;
  50   1          msdelay(20);
  51   1          e=0;
  52   1        msdelay(20);
  53   1        display_port = ((disp_data<<4) & 0xF0);
  54   1          rs= 1;
C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2021 15:33:06 PAGE 2   

  55   1          rw=0;
  56   1          e=1;
  57   1          msdelay(20);
  58   1          e=0;
  59   1          
  60   1      }
  61          
  62          
  63          void lcd_string_data(const char *p)
  64          {
  65   1        while(*p!='\0')
  66   1        {
  67   2          lcd_char_data(*p);
  68   2          p++;
  69   2          msdelay(20);
  70   2        }
  71   1      }
  72          
  73           void lcd_init()    //Function to prepare the LCD  and get it ready
  74          {
  75   1          lcd_cmd(0x28);  // for 2 lines and 5X7 matrix of LCD(4 bit mode)
  76   1          //lcd_cmd(0x38);
  77   1          //lcd_cmd(0x38);
  78   1          //lcd_cmd(0x38);
  79   1          msdelay(20);
  80   1          lcd_cmd(0x0E);  // turn display ON, cursor blinking
  81   1          msdelay(20);
  82   1          lcd_cmd(0x06);  //Entry Mode
  83   1          msdelay(20);
  84   1          lcd_cmd(0x01);  //clear screen
  85   1          msdelay(20);
  86   1          lcd_cmd(0x80);  // bring cursor to position 1 of line 1
  87   1          msdelay(20);
  88   1      }
  89          int row_finder1() //Function for finding the row for column 1
  90          {
  91   1      int key;
  92   1      R1=R2=R3=R4=1;
  93   1      C1=C2=C3=C4=0;
  94   1      if(R1==0)
  95   1      {
  96   2        key='7';
  97   2        lcd_char_data('7'); 
  98   2      }
  99   1      else if(R2==0)
 100   1      {
 101   2        key='4';
 102   2        lcd_char_data('4');
 103   2      }
 104   1      else if(R3==0)
 105   1      {
 106   2        key='1';
 107   2        lcd_char_data('1');
 108   2      }
 109   1      else if(R4==0)
 110   1      { key='%';
 111   2        lcd_char_data('%');
 112   2      }
 113   1      return key;
 114   1      }
 115          int row_finder2() //Function for finding the row for column 2
 116          {
C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2021 15:33:06 PAGE 3   

 117   1      int key;
 118   1      R1=R2=R3=R4=1;
 119   1      C1=C2=C3=C4=0;
 120   1      if(R1==0)
 121   1      { 
 122   2        key='8';
 123   2      lcd_char_data('8');
 124   2      }
 125   1      else if(R2==0)
 126   1      { 
 127   2        key='5';
 128   2      lcd_char_data('5');
 129   2      }
 130   1      else if(R3==0)
 131   1      {
 132   2        key='2';
 133   2      lcd_char_data('2');
 134   2      } 
 135   1      else if(R4==0)
 136   1      { 
 137   2        key='0';
 138   2      lcd_char_data('0');
 139   2      }
 140   1      return key;
 141   1      }
 142          int row_finder3() //Function for finding the row for column 3
 143          {
 144   1      R1=R2=R3=R4=1;
 145   1      C1=C2=C3=C4=0;
 146   1      if(R1==0)
 147   1      {
 148   2        key='9';
 149   2      lcd_char_data('9');
 150   2      }
 151   1      else if(R2==0)
 152   1      {
 153   2        key='6';
 154   2      lcd_char_data('6');
 155   2      }
 156   1      else if(R3==0)
 157   1      { 
 158   2        key='3';
 159   2      lcd_char_data('3');
 160   2      }
 161   1      else if(R4==0)
 162   1      {
 163   2        key='=';
 164   2      lcd_char_data('=');
 165   2      }
 166   1      return key;
 167   1      }
 168          int row_finder4() //Function for finding the row for column 4
 169          {
 170   1      
 171   1      R1=R2=R3=R4=1;
 172   1      C1=C2=C3=C4=0;
 173   1      if(R1==0)
 174   1      {
 175   2      lcd_char_data('/');
 176   2      }
 177   1      if(R2==0)
 178   1      {
C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2021 15:33:06 PAGE 4   

 179   2      lcd_char_data('*');
 180   2      }
 181   1      if(R3==0)
 182   1      {
 183   2      lcd_char_data('-');
 184   2      }
 185   1      if(R4==0)
 186   1      {
 187   2      lcd_char_data('+');
 188   2      }
 189   1      return key;
 190   1      }
 191          
 192          int keypad()
 193          {
 194   1      int x;
 195   1      while(1)
 196   1          {  
 197   2                      
 198   2                msdelay(30); 
 199   2                C1=C2=C3=C4=1;
 200   2                R1=R2=R3=R4=0;
 201   2                if(C1==0)
 202   2                {
 203   3                x=row_finder1();
 204   3                  break;
 205   3                }
 206   2                else if(C2==0)
 207   2                {
 208   3                  x=row_finder2();
 209   3                  break;
 210   3                }
 211   2                else if(C3==0)
 212   2                {
 213   3                  x=row_finder3();
 214   3                  break;
 215   3                }
 216   2                else if(C4==0)
 217   2                {
 218   3                  x=row_finder4();
 219   3                  break;
 220   3                }       
 221   2            
 222   2          }
 223   1          return x; 
 224   1      }
 225          void main()
 226          {
 227   1        int lcd_arr[3];
 228   1        int i;
 229   1        unsigned int n;
 230   1        lcd_init();
 231   1        lcd_string_data("TSE-2018");
 232   1        while(1)
 233   1        {
 234   2          lcd_cmd(0xC0);
 235   2          msdelay(20);
 236   2          n=0;
 237   2          for(i=0;i<=2;i++)
 238   2          {
 239   3            lcd_arr[i]=keypad();
 240   3          }       
C51 COMPILER V9.60.0.0   MAIN                                                              03/03/2021 15:33:06 PAGE 5   

 241   2          n=(lcd_arr[0]*100)+(lcd_arr[1]*10)+lcd_arr[2]+48;
 242   2          toDAC=n;
 243   2          msdelay(100);
 244   2        }              
 245   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    618    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
